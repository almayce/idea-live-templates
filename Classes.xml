<templateSet group="Classes">
  <template name="observable list" value="public class ObservableList&lt;T&gt; {&#10;    private List&lt;T&gt; list;&#10;    private PublishSubject&lt;T&gt; onRemove;&#10;    private PublishSubject&lt;T&gt; onAdd;&#10;    private T backup;&#10;&#10;    public IngredientsObservableList() {&#10;        this.list = new ArrayList&lt;T&gt;();&#10;        this.onRemove = PublishSubject.create();&#10;        this.onAdd = PublishSubject.create();&#10;    }&#10;&#10;    public void add(T val) {&#10;        onAdd.onNext(val);&#10;        list.add(val);&#10;    }&#10;&#10;    public void remove(T val) {&#10;        backup = val;&#10;        onRemove.onNext(val);&#10;        list.remove(val);&#10;    }&#10;&#10;    public void remove(int position) {&#10;        backup = list.get(position);&#10;        onRemove.onNext(list.get(position));&#10;        list.remove(position);&#10;    }&#10;&#10;    public boolean contains(T val) {&#10;        return list.contains(val);&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return list.isEmpty();&#10;    }&#10;&#10;    public void resurrect() {&#10;        onAdd.onNext(backup);&#10;        list.add(backup);&#10;    }&#10;&#10;    public int size() {&#10;        return list.size();&#10;    }&#10;&#10;    public T get(int position) {&#10;        return list.get(position);&#10;    }&#10;&#10;    public List&lt;T&gt; getList() {&#10;        return list;&#10;    }&#10;&#10;    public PublishSubject&lt;T&gt; getOnAddObservable(){&#10;        return onAdd;&#10;    }&#10;&#10;    public PublishSubject&lt;T&gt; getOnRemoveObservable(){&#10;        return onRemove;&#10;    }&#10;}" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="schedulers transformer" value="public class SchedulersTransformer&lt;T&gt; implements ObservableTransformer&lt;T, T&gt; {&#10;&#10;    @Override&#10;    public ObservableSource&lt;T&gt; apply(Observable&lt;T&gt; upstream) {&#10;        return upstream&#10;                .subscribeOn(Schedulers.newThread())&#10;                .observeOn(AndroidSchedulers.mainThread());&#10;    }&#10;}" description="class" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="custom auto complete text view" value="public class CustomAutoCompleteTextView extends android.support.v7.widget.AppCompatAutoCompleteTextView {&#10;        public CustomAutoCompleteTextView(Context context) {&#10;            super(context);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;&#10;        public CustomAutoCompleteTextView(Context context, AttributeSet attrs) {&#10;            super(context, attrs);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;&#10;        public CustomAutoCompleteTextView(Context context, AttributeSet attrs, int defStyleAttr) {&#10;            super(context, attrs, defStyleAttr);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="custom text view" value="public class CustomTextView extends android.support.v7.widget.AppCompatTextView {&#10;        public CustomTextView(Context context) {&#10;            super(context);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;&#10;        public CustomTextView(Context context, AttributeSet attrs) {&#10;            super(context, attrs);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;&#10;        public CustomTextView(Context context, AttributeSet attrs,&#10;                              int defStyle) {&#10;            super(context, attrs, defStyle);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="custom type face" value="public class CustomTypeFace {&#10;&#10;        private static TemplateJava.CustomTypeFace instance;&#10;        private static Typeface typeface;&#10;&#10;        public static TemplateJava.CustomTypeFace getInstance(Context context) {&#10;            synchronized (TemplateJava.CustomTypeFace.class) {&#10;                if (instance == null) {&#10;                    instance = new TemplateJava.CustomTypeFace();&#10;                    typeface = Typeface.createFromAsset(context.getResources().getAssets(), &quot;fonts/font.ttf&quot;);&#10;                }&#10;                return instance;&#10;            }&#10;        }&#10;&#10;        public Typeface getTypeFace() {&#10;            return typeface;&#10;        }&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="swipe detector horizantal" value="public class HorizontalSwipeDetector implements View.OnTouchListener {&#10;&#10;        static final java.lang.String logTag = &quot;VerticalSwipeDetector&quot;;&#10;        private TemplateJava.HorizontalSwipeInterface activity;&#10;        static final int MIN_DISTANCE = 100;&#10;        private float downX, downY, upX, upY;&#10;&#10;        public HorizontalSwipeDetector(TemplateJava.HorizontalSwipeInterface activity){&#10;            this.activity = activity;&#10;        }&#10;&#10;        public void onRightToLeftSwipe(View v){&#10;            Log.i(logTag, &quot;RightToLeftSwipe!&quot;);&#10;            activity.rightToLeft(v);&#10;        }&#10;&#10;        public void onLeftToRightSwipe(View v){&#10;            Log.i(logTag, &quot;LeftToRightSwipe!&quot;);&#10;            activity.leftToRight(v);&#10;        }&#10;&#10;        public boolean onTouch(View v, MotionEvent event) {&#10;            switch(event.getAction()){&#10;                case MotionEvent.ACTION_DOWN: {&#10;                    downX = event.getX();&#10;                    downY = event.getY();&#10;                    return true;&#10;                }&#10;                case MotionEvent.ACTION_UP: {&#10;                    upX = event.getX();&#10;                    upY = event.getY();&#10;&#10;                    float deltaX = downX - upX;&#10;                    float deltaY = downY - upY;&#10;&#10;                    if(java.lang.Math.abs(deltaX) &gt; MIN_DISTANCE){&#10;                        if(deltaX &lt; 0) { this.onLeftToRightSwipe(v); return true; }&#10;                        if(deltaX &gt; 0) { this.onRightToLeftSwipe(v); return true; }&#10;                    }&#10;                    else {&#10;                        Log.i(logTag, &quot;Swipe was only &quot; + java.lang.Math.abs(deltaX) + &quot; long, need at least &quot; + MIN_DISTANCE);&#10;                    }&#10;                }&#10;            }&#10;            return false;&#10;        }&#10;    }&#10;&#10;    public interface HorizontalSwipeInterface {&#10;&#10;        public void leftToRight(View v);&#10;&#10;        public void rightToLeft(View v);&#10;&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="swipe detector vertical" value="public class VerticalSwipeDetector implements View.OnTouchListener {&#10;&#10;        static final java.lang.String logTag = &quot;VerticalSwipeDetector&quot;;&#10;        private TemplateJava.VerticalSwipeInterface activity;&#10;        static final int MIN_DISTANCE = 100;&#10;        private float downX, downY, upX, upY;&#10;&#10;        public VerticalSwipeDetector(TemplateJava.VerticalSwipeInterface activity){&#10;            this.activity = activity;&#10;        }&#10;&#10;        public void onTopToBottomSwipe(View v){&#10;            Log.i(logTag, &quot;onTopToBottomSwipe!&quot;);&#10;            activity.topToBottom(v);&#10;        }&#10;&#10;        public void onBottomToTopSwipe(View v){&#10;            Log.i(logTag, &quot;onBottomToTopSwipe!&quot;);&#10;            activity.bottomToTop(v);&#10;        }&#10;&#10;        public boolean onTouch(View v, MotionEvent event) {&#10;            switch(event.getAction()){&#10;                case MotionEvent.ACTION_DOWN: {&#10;                    downX = event.getX();&#10;                    downY = event.getY();&#10;                    return true;&#10;                }&#10;                case MotionEvent.ACTION_UP: {&#10;                    upX = event.getX();&#10;                    upY = event.getY();&#10;&#10;                    float deltaX = downX - upX;&#10;                    float deltaY = downY - upY;&#10;&#10;                    if(java.lang.Math.abs(deltaY) &gt; MIN_DISTANCE){&#10;                        if(deltaY &lt; 0) { this.onTopToBottomSwipe(v); return true; }&#10;                        if(deltaY &gt; 0) { this.onBottomToTopSwipe(v); return true; }&#10;                    }&#10;                    else {&#10;                        Log.i(logTag, &quot;Swipe was only &quot; + java.lang.Math.abs(deltaX) + &quot; long, need at least &quot; + MIN_DISTANCE);&#10;                    }&#10;                }&#10;            }&#10;            return false;&#10;        }&#10;    }&#10;&#10;    public interface VerticalSwipeInterface {&#10;&#10;        public void bottomToTop(View v);&#10;&#10;        public void topToBottom(View v);&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="quicksorter" value="class QuickSorter {&#10;    private var numbers = ArrayList&lt;Int&gt;()&#10;&#10;    fun sort(values: ArrayList&lt;Int&gt;): ArrayList&lt;Int&gt; {&#10;        this.numbers = values&#10;        if (values.size != 0)&#10;            quicksort(0, values.size - 1)&#10;        return numbers&#10;    }&#10;&#10;    tailrec private fun quicksort(low: Int, high: Int) {&#10;        var i = low&#10;        var j = high&#10;        val pivot = numbers[low + (high - low) / 2]&#10;&#10;        while (i &lt;= j) {&#10;            while (numbers[i] &lt; pivot) i++&#10;            while (numbers[j] &gt; pivot) j--&#10;            if (i &lt;= j) {&#10;                exchange(i, j)&#10;                i++&#10;                j--&#10;            }&#10;        }&#10;        // Recursion&#10;        if (low &lt; j)&#10;            quicksort(low, j)&#10;        if (i &lt; high)&#10;            quicksort(i, high)&#10;    }&#10;&#10;    private fun exchange(i: Int, j: Int) {&#10;        val temp = numbers.get(i)&#10;        numbers.set(i, numbers.get(j))&#10;        numbers.set(j, temp)&#10;    }&#10;}" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN_CLASS" value="true" />
    </context>
  </template>
</templateSet>