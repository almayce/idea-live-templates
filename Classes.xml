<templateSet group="Classes">
  <template name="observable list" value="public class ObservableList&lt;T&gt; {&#10;    private List&lt;T&gt; list;&#10;    private PublishSubject&lt;T&gt; onRemove;&#10;    private PublishSubject&lt;T&gt; onAdd;&#10;    private T backup;&#10;&#10;    public IngredientsObservableList() {&#10;        this.list = new ArrayList&lt;T&gt;();&#10;        this.onRemove = PublishSubject.create();&#10;        this.onAdd = PublishSubject.create();&#10;    }&#10;&#10;    public void add(T val) {&#10;        onAdd.onNext(val);&#10;        list.add(val);&#10;    }&#10;&#10;    public void remove(T val) {&#10;        backup = val;&#10;        onRemove.onNext(val);&#10;        list.remove(val);&#10;    }&#10;&#10;    public void remove(int position) {&#10;        backup = list.get(position);&#10;        onRemove.onNext(list.get(position));&#10;        list.remove(position);&#10;    }&#10;&#10;    public boolean contains(T val) {&#10;        return list.contains(val);&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return list.isEmpty();&#10;    }&#10;&#10;    public void resurrect() {&#10;        onAdd.onNext(backup);&#10;        list.add(backup);&#10;    }&#10;&#10;    public int size() {&#10;        return list.size();&#10;    }&#10;&#10;    public T get(int position) {&#10;        return list.get(position);&#10;    }&#10;&#10;    public List&lt;T&gt; getList() {&#10;        return list;&#10;    }&#10;&#10;    public PublishSubject&lt;T&gt; getOnAddObservable(){&#10;        return onAdd;&#10;    }&#10;&#10;    public PublishSubject&lt;T&gt; getOnRemoveObservable(){&#10;        return onRemove;&#10;    }&#10;}" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="schedulers transformer" value="public class SchedulersTransformer&lt;T&gt; implements ObservableTransformer&lt;T, T&gt; {&#10;&#10;    @Override&#10;    public ObservableSource&lt;T&gt; apply(Observable&lt;T&gt; upstream) {&#10;        return upstream&#10;                .subscribeOn(Schedulers.newThread())&#10;                .observeOn(AndroidSchedulers.mainThread());&#10;    }&#10;}" description="class" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="custom auto complete text view" value="public class CustomAutoCompleteTextView extends android.support.v7.widget.AppCompatAutoCompleteTextView {&#10;        public CustomAutoCompleteTextView(Context context) {&#10;            super(context);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;&#10;        public CustomAutoCompleteTextView(Context context, AttributeSet attrs) {&#10;            super(context, attrs);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;&#10;        public CustomAutoCompleteTextView(Context context, AttributeSet attrs, int defStyleAttr) {&#10;            super(context, attrs, defStyleAttr);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="custom text view" value="public class CustomTextView extends android.support.v7.widget.AppCompatTextView {&#10;        public CustomTextView(Context context) {&#10;            super(context);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;&#10;        public CustomTextView(Context context, AttributeSet attrs) {&#10;            super(context, attrs);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;&#10;        public CustomTextView(Context context, AttributeSet attrs,&#10;                              int defStyle) {&#10;            super(context, attrs, defStyle);&#10;            setTypeface(CustomTypeFace.getInstance(context).getTypeFace());&#10;        }&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="custom type face" value="public class CustomTypeFace {&#10;&#10;        private static TemplateJava.CustomTypeFace instance;&#10;        private static Typeface typeface;&#10;&#10;        public static TemplateJava.CustomTypeFace getInstance(Context context) {&#10;            synchronized (TemplateJava.CustomTypeFace.class) {&#10;                if (instance == null) {&#10;                    instance = new TemplateJava.CustomTypeFace();&#10;                    typeface = Typeface.createFromAsset(context.getResources().getAssets(), &quot;fonts/font.ttf&quot;);&#10;                }&#10;                return instance;&#10;            }&#10;        }&#10;&#10;        public Typeface getTypeFace() {&#10;            return typeface;&#10;        }&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="swipe detector horizantal" value="public class HorizontalSwipeDetector implements View.OnTouchListener {&#10;&#10;        static final java.lang.String logTag = &quot;VerticalSwipeDetector&quot;;&#10;        private TemplateJava.HorizontalSwipeInterface activity;&#10;        static final int MIN_DISTANCE = 100;&#10;        private float downX, downY, upX, upY;&#10;&#10;        public HorizontalSwipeDetector(TemplateJava.HorizontalSwipeInterface activity){&#10;            this.activity = activity;&#10;        }&#10;&#10;        public void onRightToLeftSwipe(View v){&#10;            Log.i(logTag, &quot;RightToLeftSwipe!&quot;);&#10;            activity.rightToLeft(v);&#10;        }&#10;&#10;        public void onLeftToRightSwipe(View v){&#10;            Log.i(logTag, &quot;LeftToRightSwipe!&quot;);&#10;            activity.leftToRight(v);&#10;        }&#10;&#10;        public boolean onTouch(View v, MotionEvent event) {&#10;            switch(event.getAction()){&#10;                case MotionEvent.ACTION_DOWN: {&#10;                    downX = event.getX();&#10;                    downY = event.getY();&#10;                    return true;&#10;                }&#10;                case MotionEvent.ACTION_UP: {&#10;                    upX = event.getX();&#10;                    upY = event.getY();&#10;&#10;                    float deltaX = downX - upX;&#10;                    float deltaY = downY - upY;&#10;&#10;                    if(java.lang.Math.abs(deltaX) &gt; MIN_DISTANCE){&#10;                        if(deltaX &lt; 0) { this.onLeftToRightSwipe(v); return true; }&#10;                        if(deltaX &gt; 0) { this.onRightToLeftSwipe(v); return true; }&#10;                    }&#10;                    else {&#10;                        Log.i(logTag, &quot;Swipe was only &quot; + java.lang.Math.abs(deltaX) + &quot; long, need at least &quot; + MIN_DISTANCE);&#10;                    }&#10;                }&#10;            }&#10;            return false;&#10;        }&#10;    }&#10;&#10;    public interface HorizontalSwipeInterface {&#10;&#10;        public void leftToRight(View v);&#10;&#10;        public void rightToLeft(View v);&#10;&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="swipe detector vertical" value="public class VerticalSwipeDetector implements View.OnTouchListener {&#10;&#10;        static final java.lang.String logTag = &quot;VerticalSwipeDetector&quot;;&#10;        private TemplateJava.VerticalSwipeInterface activity;&#10;        static final int MIN_DISTANCE = 100;&#10;        private float downX, downY, upX, upY;&#10;&#10;        public VerticalSwipeDetector(TemplateJava.VerticalSwipeInterface activity){&#10;            this.activity = activity;&#10;        }&#10;&#10;        public void onTopToBottomSwipe(View v){&#10;            Log.i(logTag, &quot;onTopToBottomSwipe!&quot;);&#10;            activity.topToBottom(v);&#10;        }&#10;&#10;        public void onBottomToTopSwipe(View v){&#10;            Log.i(logTag, &quot;onBottomToTopSwipe!&quot;);&#10;            activity.bottomToTop(v);&#10;        }&#10;&#10;        public boolean onTouch(View v, MotionEvent event) {&#10;            switch(event.getAction()){&#10;                case MotionEvent.ACTION_DOWN: {&#10;                    downX = event.getX();&#10;                    downY = event.getY();&#10;                    return true;&#10;                }&#10;                case MotionEvent.ACTION_UP: {&#10;                    upX = event.getX();&#10;                    upY = event.getY();&#10;&#10;                    float deltaX = downX - upX;&#10;                    float deltaY = downY - upY;&#10;&#10;                    if(java.lang.Math.abs(deltaY) &gt; MIN_DISTANCE){&#10;                        if(deltaY &lt; 0) { this.onTopToBottomSwipe(v); return true; }&#10;                        if(deltaY &gt; 0) { this.onBottomToTopSwipe(v); return true; }&#10;                    }&#10;                    else {&#10;                        Log.i(logTag, &quot;Swipe was only &quot; + java.lang.Math.abs(deltaX) + &quot; long, need at least &quot; + MIN_DISTANCE);&#10;                    }&#10;                }&#10;            }&#10;            return false;&#10;        }&#10;    }&#10;&#10;    public interface VerticalSwipeInterface {&#10;&#10;        public void bottomToTop(View v);&#10;&#10;        public void topToBottom(View v);&#10;    }" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="quicksorter" value="class QuickSorter {&#10;    private var numbers = ArrayList&lt;Int&gt;()&#10;&#10;    fun sort(values: ArrayList&lt;Int&gt;): ArrayList&lt;Int&gt; {&#10;        this.numbers = values&#10;        if (values.size != 0)&#10;            quicksort(0, values.size - 1)&#10;        return numbers&#10;    }&#10;&#10;    tailrec private fun quicksort(low: Int, high: Int) {&#10;        var i = low&#10;        var j = high&#10;        val pivot = numbers[low + (high - low) / 2]&#10;&#10;        while (i &lt;= j) {&#10;            while (numbers[i] &lt; pivot) i++&#10;            while (numbers[j] &gt; pivot) j--&#10;            if (i &lt;= j) {&#10;                exchange(i, j)&#10;                i++&#10;                j--&#10;            }&#10;        }&#10;        // Recursion&#10;        if (low &lt; j)&#10;            quicksort(low, j)&#10;        if (i &lt; high)&#10;            quicksort(i, high)&#10;    }&#10;&#10;    private fun exchange(i: Int, j: Int) {&#10;        val temp = numbers.get(i)&#10;        numbers.set(i, numbers.get(j))&#10;        numbers.set(j, temp)&#10;    }&#10;}" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN_CLASS" value="true" />
    </context>
  </template>
  <template name="system monitor" value="object SystemMonitor {&#10;&#10;    private val bean = ManagementFactory&#10;            .getOperatingSystemMXBean() as OperatingSystemMXBean&#10;&#10;    private val runtimeSystemUsage: String&#10;        get() {&#10;            val cpu = bean.systemCpuLoad * 100&#10;            val prc = bean.processCpuLoad * 100&#10;            val ram = Runtime.getRuntime().totalMemory().toFloat() / 1073741824&#10;&#10;            val cpuString = &quot;CPU ${cpu.toInt()} %&quot;&#10;            val prcString = &quot;PRC ${prc.toInt()} %&quot;&#10;            val ramString = &quot;RAM ${round(ram, 1)} gb&quot;&#10;&#10;            return &quot;$cpuString $prcString $ramString&quot;&#10;        }&#10;&#10;    private fun round(d: Float, decimalPlace: Int) =&#10;            d.toBigDecimal().setScale(decimalPlace, BigDecimal.ROUND_HALF_UP).toFloat()&#10;&#10;    fun printUsage(action: String, target: String) =&#10;        println(&quot;$runtimeSystemUsage | $action $target&quot;)&#10;}" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN_TOPLEVEL" value="true" />
    </context>
  </template>
  <template name="selenoid" value="public class SelenoidWebDriverProvider implements WebDriverProvider {&#10;&#10;    @java.lang.Override&#10;    public WebDriver createDriver(DesiredCapabilities capabilities) {&#10;        DesiredCapabilities browser = new DesiredCapabilities();&#10;        browser.setBrowserName(&quot;chrome&quot;);&#10;        browser.setVersion(&quot;70.0&quot;);&#10;        browser.setCapability(&quot;enableVNC&quot;, true);&#10;&#10;        try {&#10;            RemoteWebDriver driver = new RemoteWebDriver(&#10;                    URI.create(&quot;http://localhost:4444/wd/hub&quot;).toURL(),&#10;                    browser&#10;            );&#10;            driver.manage().window().setSize(new Dimension(1280, 1024));&#10;            return driver;&#10;        } catch (MalformedURLException e) {&#10;            throw new java.lang.RuntimeException(e);&#10;        }&#10;    }&#10;}" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="dead link detector" value="object DeadLinkDetector {&#10;&#10;    fun execute() {&#10;        val executors = Executors.newFixedThreadPool(30)&#10;        val hrefCollection = Selenide.`$$`(By.xpath(&quot;.//a[@href!='']&quot;))&#10;&#10;        for (hrefElement in hrefCollection)&#10;            executors.execute(RunnableUnit(hrefElement))&#10;&#10;        executors.shutdown()&#10;&#10;        while (!executors.isTerminated)&#10;            sleep(1)&#10;&#10;        val builder = StringBuilder()&#10;        if (errorList.size &gt; 0) {&#10;            for (link in errorList)&#10;                builder.append(link).append(&quot;\n&quot;)&#10;            AllureAttachment.text(&quot;Broken Links&quot;, builder.toString())&#10;        }&#10;    }&#10;&#10;    class RunnableUnit internal constructor(private val hrefEl: WebElement) : Runnable {&#10;        override fun run() {&#10;            sendGet(hrefEl)&#10;        }&#10;    }&#10;&#10;    var errorList: MutableList&lt;String&gt; = ArrayList()&#10;&#10;    private fun sendGet(element: WebElement) {&#10;&#10;        val href = element.getAttribute(&quot;href&quot;)&#10;        val client = DefaultHttpClient()&#10;        val request = HttpGet(href)&#10;        var response: HttpResponse? = null&#10;        try {&#10;            response = client.execute(request)&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;        }&#10;        val code = response!!.statusLine.statusCode&#10;        if (code != 200)&#10;            errorList.add(href)&#10;    }&#10;}" description="class" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN_TOPLEVEL" value="true" />
    </context>
  </template>
</templateSet>